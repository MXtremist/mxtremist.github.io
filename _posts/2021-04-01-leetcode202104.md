---
layout: post
title: 力扣每日一题 2021/4
date: 2021-04-01
Author: MXtremist
categories: 
tags: [practice, note]

comments: true
--- 

<!-- more -->



##### 4/1 笨阶乘

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/clumsy-factorial/)

今天是愚人节，我直呼上当了。。写了个每四个一计算再累加的O(n)算法，然而没想到最终结果是可以直接用表达式的。。也就是O(1)。。



##### 4/2 直方图的水量

难度 <font color="Crimson">HARD</font>	[链接](https://leetcode-cn.com/problems/volume-of-histogram-lcci/) 

以前算法课做过，然而只是大概记得一点。。最重要的是：一个点，左侧最大<右侧最大，则该位置存水量=左侧最大-自己，另一种情况也一样。

然后就可以用两个指针（指向当前左、右位置）和两个值（表示当前左最大和右最大）来实现了。



##### 4/3 最长公共子序列

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/longest-common-subsequence/) 

经典dp题目，转移方程是：

$dp[i][j] = dp[i-1][j-1]+1,\ if\ s[i]=t[j]$

$dp[i][j] = MAX\{dp[i-1][j],dp[i][j-2]\},\ if\ s[i]!=t[j]$

比较容易理解。



##### 4/4  森林中的兔子

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/rabbits-in-forest/)

很简单的题目，不过倒是让我知道了C++里的hash容器unordered_map。



##### 4/5 合并两个有序数组

难度 <font color="Limegreen">EASY</font>	[链接](https://leetcode-cn.com/problems/merge-sorted-array/)

没啥好说的。这两天可能是双指针专题。



##### 4/6 删除有序数组中的重复项 II

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array-ii/) 

确实又是双指针。。不过我没想到，用的是简单一点的两次遍历的方法，第一次标记重复的，第二次移动，但是其实可以放在一个遍历里使用双指针完成。具体做法就是第一个指针指向接下来遍历到的数字，第二个指针指向接下来需要前移的数字前移的位置（当nums[i] != nums[i-2]时就需要前移）。



##### 4/7 搜索旋转排序数组 II

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/search-in-rotated-sorted-array-ii/) 

旋转排序其实就是两段非降序数组拼接，并且第一个的最小值（left）大于等于第二个的最大值（right），如下图。

<img src="https://i.loli.net/2021/04/07/OpAsWtimahCI4TV.png"/>

那么在两种情况下是有序的，即mid在分割点的左边，则[left:mid]有序，若此时nums[left] <= target \< nums[mid] 就可以使用二分法；mid在分割点的右边，则[mid:right]有序，若此时nums[right] \>= target > nums[mid]就可以使用二分法。否则则去掉这一半，依然起到二分法作用。

由于非降序，只有一种情况下不是二分，即nums[left] == nums[mid]，此时无法判断属于那种情况，只能left++。



##### 4/8 寻找旋转排序数组中的最小值

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array/) 

和昨天的基本一个思路，不过由于元素各不相同判断要简单一点，当nums[left] <= nums[mid] 时就说明这一部分有序，此时nums[left]就是这部分最小值，接下来去剩下的继续找就行；另一种情况也一样。



##### 4/9 寻找旋转排序数组中的最小值 II

难度 <font color="Crimson">HARD</font>	[链接](https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii/)

改成了可重复，那么就用4.7.的方法，在最坏情况会退化为O(n)。



##### 4/10 丑数

难度 <font color="Limegreen">EASY</font>	[链接](https://leetcode-cn.com/problems/ugly-number/)

简单，不说了。。。



##### 4/11 丑数 II

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/ugly-number-ii/)

先创建一个大小为n的数组vec，vec[0]为1.然后有三个指针指向当前选用的\*2、\*3、\*5的备选数，初始指向vec[0]，之后，每次将三者中最小的那个作为vec[i]并将其指针数+1。这样，下一个要填的数比三者当前指向的大，比三者*相应倍数的小（或等于），那么就是下一个满足条件的数。如果有重复，比如6=2×3=3×2，那么这时候两个指针指向的都是最小的，将两个都加1即可。



##### 4/12 最大数

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/largest-number/)

我的做法是将其全部转化为string后排序，排序使用的规则为:

```c++
bool mygreater(string a, string b){
    return a+b > b+a;
}
```

这样排序过后就直接按顺序增加到结果string中即可。



##### 4/13 二叉搜索树节点最小距离

难度 <font color="Limegreen">EASY</font>	[链接](https://leetcode-cn.com/problems/minimum-distance-between-bst-nodes/)

由于是二叉搜索树，故中序遍历即可，因为这样得到的顺序就是从大到小的顺序，最小差值就出现在相邻的数值中间。



##### 4/14 实现 Trie (前缀树)

难度 <font color="Gold">MEDI</font>	[链接](https://leetcode-cn.com/problems/implement-trie-prefix-tree/)

前缀树早就忘了。。所以先上网看了看。在理解前缀树的定义之后写起来还是比较简单的。



##### 4/

难度 <font color="Limegreen">EASY</font>	[链接]

##### 4/

难度 <font color="Gold">MEDI</font>	[链接]

##### 4/

难度 <font color="Crimson">HARD</font>	[链接]